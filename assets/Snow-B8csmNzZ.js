var $t=Object.defineProperty;var Kt=(c,t,e)=>t in c?$t(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var q=(c,t,e)=>(Kt(c,typeof t!="symbol"?t+"":t,e),e);import{S as B,P as yt,a as at,C as U,b as ct,R as Jt,c as te,d as ee,E as ie,M as Lt,A as se,e as K,_ as he,q as ne,f as re,p as Mt,u as ae}from"./main-D7DpCR7x.js";import{e as le,B as oe,a as ue,W as Dt,b as Ct,c as Rt,d as Et,D as ht,T as J,C as Ot,S as Ft,f as jt,U as ce,g as Vt,h as de,G as pe,i as H,j as dt,E as ge,k as ye,O as be,l as me,A as fe}from"./ResizePlugin-DfJql_U7.js";const xe="_snow_hp0qe_1",_e={snow:xe};function we(c,t=null){const e=c*6;if(t=t||new Uint16Array(e),t.length!==e)throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${e}`);for(let s=0,i=0;s<e;s+=6,i+=4)t[s+0]=i+0,t[s+1]=i+1,t[s+2]=i+2,t[s+3]=i+0,t[s+4]=i+2,t[s+5]=i+3;return t}const lt={build(c){const t=c.points;let e,s,i,h,n,r;if(c.type===B.CIRC){const p=c.shape;e=p.x,s=p.y,n=r=p.radius,i=h=0}else if(c.type===B.ELIP){const p=c.shape;e=p.x,s=p.y,n=p.width,r=p.height,i=h=0}else{const p=c.shape,y=p.width/2,x=p.height/2;e=p.x+y,s=p.y+x,n=r=Math.max(0,Math.min(p.radius,Math.min(y,x))),i=y-n,h=x-r}if(!(n>=0&&r>=0&&i>=0&&h>=0)){t.length=0;return}const a=Math.ceil(2.3*Math.sqrt(n+r)),o=a*8+(i?4:0)+(h?4:0);if(t.length=o,o===0)return;if(a===0){t.length=8,t[0]=t[6]=e+i,t[1]=t[3]=s+h,t[2]=t[4]=e-i,t[5]=t[7]=s-h;return}let l=0,d=a*4+(i?2:0)+2,u=d,b=o;{const p=i+n,y=h,x=e+p,f=e-p,_=s+y;if(t[l++]=x,t[l++]=_,t[--d]=_,t[--d]=f,h){const g=s-y;t[u++]=f,t[u++]=g,t[--b]=g,t[--b]=x}}for(let p=1;p<a;p++){const y=Math.PI/2*(p/a),x=i+Math.cos(y)*n,f=h+Math.sin(y)*r,_=e+x,g=e-x,m=s+f,C=s-f;t[l++]=_,t[l++]=m,t[--d]=m,t[--d]=g,t[u++]=g,t[u++]=C,t[--b]=C,t[--b]=_}{const p=i,y=h+r,x=e+p,f=e-p,_=s+y,g=s-y;t[l++]=x,t[l++]=_,t[--b]=g,t[--b]=x,i&&(t[l++]=f,t[l++]=_,t[--b]=g,t[--b]=f)}},triangulate(c,t){const e=c.points,s=t.points,i=t.indices;if(e.length===0)return;let h=s.length/2;const n=h;let r,a;if(c.type!==B.RREC){const l=c.shape;r=l.x,a=l.y}else{const l=c.shape;r=l.x+l.width/2,a=l.y+l.height/2}const o=c.matrix;s.push(c.matrix?o.a*r+o.c*a+o.tx:r,c.matrix?o.b*r+o.d*a+o.ty:a),h++,s.push(e[0],e[1]);for(let l=2;l<e.length;l+=2)s.push(e[l],e[l+1]),i.push(h++,n,h);i.push(n+1,n,h)}};function It(c,t=!1){const e=c.length;if(e<6)return;let s=0;for(let i=0,h=c[e-2],n=c[e-1];i<e;i+=2){const r=c[i],a=c[i+1];s+=(r-h)*(a+n),h=r,n=a}if(!t&&s>0||t&&s<=0){const i=e/2;for(let h=i+i%2;h<e;h+=2){const n=e-h-2,r=e-h-1,a=h,o=h+1;[c[n],c[a]]=[c[a],c[n]],[c[r],c[o]]=[c[o],c[r]]}}}const kt={build(c){c.points=c.shape.points.slice()},triangulate(c,t){let e=c.points;const s=c.holes,i=t.points,h=t.indices;if(e.length>=6){It(e,!1);const n=[];for(let o=0;o<s.length;o++){const l=s[o];It(l.points,!0),n.push(e.length/2),e=e.concat(l.points)}const r=le(e,n,2);if(!r)return;const a=i.length/2;for(let o=0;o<r.length;o+=3)h.push(r[o]+a),h.push(r[o+1]+a),h.push(r[o+2]+a);for(let o=0;o<e.length;o++)i.push(e[o])}}},Se={build(c){const t=c.shape,e=t.x,s=t.y,i=t.width,h=t.height,n=c.points;n.length=0,i>=0&&h>=0&&n.push(e,s,e+i,s,e+i,s+h,e,s+h)},triangulate(c,t){const e=c.points,s=t.points;if(e.length===0)return;const i=s.length/2;s.push(e[0],e[1],e[2],e[3],e[6],e[7],e[4],e[5]),t.indices.push(i,i+1,i+2,i+1,i+2,i+3)}},ve={build(c){lt.build(c)},triangulate(c,t){lt.triangulate(c,t)}};var A=(c=>(c.MITER="miter",c.BEVEL="bevel",c.ROUND="round",c))(A||{}),L=(c=>(c.BUTT="butt",c.ROUND="round",c.SQUARE="square",c))(L||{});const Y={adaptive:!0,maxLength:10,minSegments:8,maxSegments:2048,epsilon:1e-4,_segmentsCount(c,t=20){if(!this.adaptive||!c||isNaN(c))return t;let e=Math.ceil(c/this.maxLength);return e<this.minSegments?e=this.minSegments:e>this.maxSegments&&(e=this.maxSegments),e}};class At{static curveTo(t,e,s,i,h,n){const r=n[n.length-2],a=n[n.length-1]-e,o=r-t,l=i-e,d=s-t,u=Math.abs(a*d-o*l);if(u<1e-8||h===0)return(n[n.length-2]!==t||n[n.length-1]!==e)&&n.push(t,e),null;const b=a*a+o*o,p=l*l+d*d,y=a*l+o*d,x=h*Math.sqrt(b)/u,f=h*Math.sqrt(p)/u,_=x*y/b,g=f*y/p,m=x*d+f*o,C=x*l+f*a,R=o*(f+_),S=a*(f+_),v=d*(x+g),M=l*(x+g),D=Math.atan2(S-C,R-m),E=Math.atan2(M-C,v-m);return{cx:m+t,cy:C+e,radius:h,startAngle:D,endAngle:E,anticlockwise:o*l>d*a}}static arc(t,e,s,i,h,n,r,a,o){const l=r-n,d=Y._segmentsCount(Math.abs(l)*h,Math.ceil(Math.abs(l)/yt)*40),u=l/(d*2),b=u*2,p=Math.cos(u),y=Math.sin(u),x=d-1,f=x%1/x;for(let _=0;_<=x;++_){const g=_+f*_,m=u+n+b*g,C=Math.cos(m),R=-Math.sin(m);o.push((p*C+y*R)*h+s,(p*-R+y*C)*h+i)}}}class Pe{constructor(){this.reset()}begin(t,e,s){this.reset(),this.style=t,this.start=e,this.attribStart=s}end(t,e){this.attribSize=e-this.attribStart,this.size=t-this.start}reset(){this.style=null,this.size=0,this.start=0,this.attribStart=0,this.attribSize=0}}class mt{static curveLength(t,e,s,i,h,n,r,a){let o=0,l=0,d=0,u=0,b=0,p=0,y=0,x=0,f=0,_=0,g=0,m=t,C=e;for(let R=1;R<=10;++R)l=R/10,d=l*l,u=d*l,b=1-l,p=b*b,y=p*b,x=y*t+3*p*l*s+3*b*d*h+u*r,f=y*e+3*p*l*i+3*b*d*n+u*a,_=m-x,g=C-f,m=x,C=f,o+=Math.sqrt(_*_+g*g);return o}static curveTo(t,e,s,i,h,n,r){const a=r[r.length-2],o=r[r.length-1];r.length-=2;const l=Y._segmentsCount(mt.curveLength(a,o,t,e,s,i,h,n));let d=0,u=0,b=0,p=0,y=0;r.push(a,o);for(let x=1,f=0;x<=l;++x)f=x/l,d=1-f,u=d*d,b=u*d,p=f*f,y=p*f,r.push(b*a+3*u*f*t+3*d*p*s+y*h,b*o+3*u*f*e+3*d*p*i+y*n)}}function Bt(c,t,e,s,i,h,n,r){const a=c-e*i,o=t-s*i,l=c+e*h,d=t+s*h;let u,b;n?(u=s,b=-e):(u=-s,b=e);const p=a+u,y=o+b,x=l+u,f=d+b;return r.push(p,y,x,f),2}function k(c,t,e,s,i,h,n,r){const a=e-c,o=s-t;let l=Math.atan2(a,o),d=Math.atan2(i-c,h-t);r&&l<d?l+=Math.PI*2:!r&&l>d&&(d+=Math.PI*2);let u=l;const b=d-l,p=Math.abs(b),y=Math.sqrt(a*a+o*o),x=(15*p*Math.sqrt(y)/Math.PI>>0)+1,f=b/x;if(u+=f,r){n.push(c,t,e,s);for(let _=1,g=u;_<x;_++,g+=f)n.push(c,t,c+Math.sin(g)*y,t+Math.cos(g)*y);n.push(c,t,i,h)}else{n.push(e,s,c,t);for(let _=1,g=u;_<x;_++,g+=f)n.push(c+Math.sin(g)*y,t+Math.cos(g)*y,c,t);n.push(i,h,c,t)}return x*2}function Te(c,t){const e=c.shape;let s=c.points||e.points.slice();const i=t.closePointEps;if(s.length===0)return;const h=c.lineStyle,n=new at(s[0],s[1]),r=new at(s[s.length-2],s[s.length-1]),a=e.type!==B.POLY||e.closeStroke,o=Math.abs(n.x-r.x)<i&&Math.abs(n.y-r.y)<i;if(a){s=s.slice(),o&&(s.pop(),s.pop(),r.set(s[s.length-2],s[s.length-1]));const T=(n.x+r.x)*.5,z=(r.y+n.y)*.5;s.unshift(T,z),s.push(T,z)}const l=t.points,d=s.length/2;let u=s.length;const b=l.length/2,p=h.width/2,y=p*p,x=h.miterLimit*h.miterLimit;let f=s[0],_=s[1],g=s[2],m=s[3],C=0,R=0,S=-(_-m),v=f-g,M=0,D=0,E=Math.sqrt(S*S+v*v);S/=E,v/=E,S*=p,v*=p;const _t=h.alignment,w=(1-_t)*2,P=_t*2;a||(h.cap===L.ROUND?u+=k(f-S*(w-P)*.5,_-v*(w-P)*.5,f-S*w,_-v*w,f+S*P,_+v*P,l,!0)+2:h.cap===L.SQUARE&&(u+=Bt(f,_,S,v,w,P,!0,l))),l.push(f-S*w,_-v*w,f+S*P,_+v*P);for(let T=1;T<d-1;++T){f=s[(T-1)*2],_=s[(T-1)*2+1],g=s[T*2],m=s[T*2+1],C=s[(T+1)*2],R=s[(T+1)*2+1],S=-(_-m),v=f-g,E=Math.sqrt(S*S+v*v),S/=E,v/=E,S*=p,v*=p,M=-(m-R),D=g-C,E=Math.sqrt(M*M+D*D),M/=E,D/=E,M*=p,D*=p;const z=g-f,Q=_-m,X=g-C,Z=R-m,wt=z*X+Q*Z,tt=Q*X-Z*z,$=tt<0;if(Math.abs(tt)<.001*Math.abs(wt)){l.push(g-S*w,m-v*w,g+S*P,m+v*P),wt>=0&&(h.join===A.ROUND?u+=k(g,m,g-S*w,m-v*w,g-M*w,m-D*w,l,!1)+4:u+=2,l.push(g-M*P,m-D*P,g+M*w,m+D*w));continue}const St=(-S+f)*(-v+m)-(-S+g)*(-v+_),vt=(-M+C)*(-D+m)-(-M+g)*(-D+R),et=(z*vt-X*St)/tt,it=(Z*St-Q*vt)/tt,Pt=(et-g)*(et-g)+(it-m)*(it-m),O=g+(et-g)*w,F=m+(it-m)*w,j=g-(et-g)*P,V=m-(it-m)*P,Qt=Math.min(z*z+Q*Q,X*X+Z*Z),Tt=$?w:P,Xt=Qt+Tt*Tt*y,Zt=Pt<=Xt;let st=h.join;if(st===A.MITER&&Pt/y>x&&(st=A.BEVEL),Zt)switch(st){case A.MITER:{l.push(O,F,j,V);break}case A.BEVEL:{$?l.push(O,F,g+S*P,m+v*P,O,F,g+M*P,m+D*P):l.push(g-S*w,m-v*w,j,V,g-M*w,m-D*w,j,V),u+=2;break}case A.ROUND:{$?(l.push(O,F,g+S*P,m+v*P),u+=k(g,m,g+S*P,m+v*P,g+M*P,m+D*P,l,!0)+4,l.push(O,F,g+M*P,m+D*P)):(l.push(g-S*w,m-v*w,j,V),u+=k(g,m,g-S*w,m-v*w,g-M*w,m-D*w,l,!1)+4,l.push(g-M*w,m-D*w,j,V));break}}else{switch(l.push(g-S*w,m-v*w,g+S*P,m+v*P),st){case A.MITER:{$?l.push(j,V,j,V):l.push(O,F,O,F),u+=2;break}case A.ROUND:{$?u+=k(g,m,g+S*P,m+v*P,g+M*P,m+D*P,l,!0)+2:u+=k(g,m,g-S*w,m-v*w,g-M*w,m-D*w,l,!1)+2;break}}l.push(g-M*w,m-D*w,g+M*P,m+D*P),u+=2}}f=s[(d-2)*2],_=s[(d-2)*2+1],g=s[(d-1)*2],m=s[(d-1)*2+1],S=-(_-m),v=f-g,E=Math.sqrt(S*S+v*v),S/=E,v/=E,S*=p,v*=p,l.push(g-S*w,m-v*w,g+S*P,m+v*P),a||(h.cap===L.ROUND?u+=k(g-S*(w-P)*.5,m-v*(w-P)*.5,g-S*w,m-v*w,g+S*P,m+v*P,l,!1)+2:h.cap===L.SQUARE&&(u+=Bt(g,m,S,v,w,P,!1,l)));const Wt=t.indices,Yt=Y.epsilon*Y.epsilon;for(let T=b;T<u+b-2;++T)f=l[T*2],_=l[T*2+1],g=l[(T+1)*2],m=l[(T+1)*2+1],C=l[(T+2)*2],R=l[(T+2)*2+1],!(Math.abs(f*(m-R)+g*(R-_)+C*(_-m))<Yt)&&Wt.push(T,T+1,T+2)}function Me(c,t){let e=0;const s=c.shape,i=c.points||s.points,h=s.type!==B.POLY||s.closeStroke;if(i.length===0)return;const n=t.points,r=t.indices,a=i.length/2,o=n.length/2;let l=o;for(n.push(i[0],i[1]),e=1;e<a;e++)n.push(i[e*2],i[e*2+1]),r.push(l,l+1),l++;h&&r.push(l,o)}function Ut(c,t){c.lineStyle.native?Me(c,t):Te(c,t)}class ft{static curveLength(t,e,s,i,h,n){const r=t-2*s+h,a=e-2*i+n,o=2*s-2*t,l=2*i-2*e,d=4*(r*r+a*a),u=4*(r*o+a*l),b=o*o+l*l,p=2*Math.sqrt(d+u+b),y=Math.sqrt(d),x=2*d*y,f=2*Math.sqrt(b),_=u/y;return(x*p+y*u*(p-f)+(4*b*d-u*u)*Math.log((2*y+_+p)/(_+f)))/(4*x)}static curveTo(t,e,s,i,h){const n=h[h.length-2],r=h[h.length-1],a=Y._segmentsCount(ft.curveLength(n,r,t,e,s,i));let o=0,l=0;for(let d=1;d<=a;++d){const u=d/a;o=n+(t-n)*u,l=r+(e-r)*u,h.push(o+(t+(s-t)*u-o)*u,l+(e+(i-e)*u-l)*u)}}}const pt={[B.POLY]:kt,[B.CIRC]:lt,[B.ELIP]:lt,[B.RECT]:Se,[B.RREC]:ve},zt=[],nt=[];class ot{constructor(t,e=null,s=null,i=null){this.points=[],this.holes=[],this.shape=t,this.lineStyle=s,this.fillStyle=e,this.matrix=i,this.type=t.type}clone(){return new ot(this.shape,this.fillStyle,this.lineStyle,this.matrix)}destroy(){this.shape=null,this.holes.length=0,this.holes=null,this.points.length=0,this.points=null,this.lineStyle=null,this.fillStyle=null}}const G=new at,qt=class Gt extends oe{constructor(){super(),this.closePointEps=1e-4,this.boundsPadding=0,this.uvsFloat32=null,this.indicesUint16=null,this.batchable=!1,this.points=[],this.colors=[],this.uvs=[],this.indices=[],this.textureIds=[],this.graphicsData=[],this.drawCalls=[],this.batchDirty=-1,this.batches=[],this.dirty=0,this.cacheDirty=-1,this.clearDirty=0,this.shapeIndex=0,this._bounds=new ue,this.boundsDirty=-1}get bounds(){return this.updateBatches(),this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds}invalidate(){this.boundsDirty=-1,this.dirty++,this.batchDirty++,this.shapeIndex=0,this.points.length=0,this.colors.length=0,this.uvs.length=0,this.indices.length=0,this.textureIds.length=0;for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].texArray.clear(),nt.push(this.drawCalls[t]);this.drawCalls.length=0;for(let t=0;t<this.batches.length;t++){const e=this.batches[t];e.reset(),zt.push(e)}this.batches.length=0}clear(){return this.graphicsData.length>0&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this}drawShape(t,e=null,s=null,i=null){const h=new ot(t,e,s,i);return this.graphicsData.push(h),this.dirty++,this}drawHole(t,e=null){if(!this.graphicsData.length)return null;const s=new ot(t,null,null,e),i=this.graphicsData[this.graphicsData.length-1];return s.lineStyle=i.lineStyle,i.holes.push(s),this.dirty++,this}destroy(){super.destroy();for(let t=0;t<this.graphicsData.length;++t)this.graphicsData[t].destroy();this.points.length=0,this.points=null,this.colors.length=0,this.colors=null,this.uvs.length=0,this.uvs=null,this.indices.length=0,this.indices=null,this.indexBuffer.destroy(),this.indexBuffer=null,this.graphicsData.length=0,this.graphicsData=null,this.drawCalls.length=0,this.drawCalls=null,this.batches.length=0,this.batches=null,this._bounds=null}containsPoint(t){const e=this.graphicsData;for(let s=0;s<e.length;++s){const i=e[s];if(i.fillStyle.visible&&i.shape&&(i.matrix?i.matrix.applyInverse(t,G):G.copyFrom(t),i.shape.contains(G.x,G.y))){let h=!1;if(i.holes){for(let n=0;n<i.holes.length;n++)if(i.holes[n].shape.contains(G.x,G.y)){h=!0;break}}if(!h)return!0}}return!1}updateBatches(){if(!this.graphicsData.length){this.batchable=!0;return}if(!this.validateBatching())return;this.cacheDirty=this.dirty;const t=this.uvs,e=this.graphicsData;let s=null,i=null;this.batches.length>0&&(s=this.batches[this.batches.length-1],i=s.style);for(let a=this.shapeIndex;a<e.length;a++){this.shapeIndex++;const o=e[a],l=o.fillStyle,d=o.lineStyle;pt[o.type].build(o),o.matrix&&this.transformPoints(o.points,o.matrix),(l.visible||d.visible)&&this.processHoles(o.holes);for(let u=0;u<2;u++){const b=u===0?l:d;if(!b.visible)continue;const p=b.texture.baseTexture,y=this.indices.length,x=this.points.length/2;p.wrapMode=Dt.REPEAT,u===0?this.processFill(o):this.processLine(o);const f=this.points.length/2-x;f!==0&&(s&&!this._compareStyles(i,b)&&(s.end(y,x),s=null),s||(s=zt.pop()||new Pe,s.begin(b,y,x),this.batches.push(s),i=b),this.addUvs(this.points,t,b.texture,x,f,b.matrix))}}const h=this.indices.length,n=this.points.length/2;if(s&&s.end(h,n),this.batches.length===0){this.batchable=!0;return}const r=n>65535;this.indicesUint16&&this.indices.length===this.indicesUint16.length&&r===this.indicesUint16.BYTES_PER_ELEMENT>2?this.indicesUint16.set(this.indices):this.indicesUint16=r?new Uint32Array(this.indices):new Uint16Array(this.indices),this.batchable=this.isBatchable(),this.batchable?this.packBatches():this.buildDrawCalls()}_compareStyles(t,e){return!(!t||!e||t.texture.baseTexture!==e.texture.baseTexture||t.color+t.alpha!==e.color+e.alpha||!!t.native!=!!e.native)}validateBatching(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(let t=0,e=this.graphicsData.length;t<e;t++){const s=this.graphicsData[t],i=s.fillStyle,h=s.lineStyle;if(i&&!i.texture.baseTexture.valid||h&&!h.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++,this.uvsFloat32=new Float32Array(this.uvs);const t=this.batches;for(let e=0,s=t.length;e<s;e++){const i=t[e];for(let h=0;h<i.size;h++){const n=i.start+h;this.indicesUint16[n]=this.indicesUint16[n]-i.attribStart}}}isBatchable(){if(this.points.length>65535*2)return!1;const t=this.batches;for(let e=0;e<t.length;e++)if(t[e].style.native)return!1;return this.points.length<Gt.BATCHABLE_SIZE*2}buildDrawCalls(){let t=++Ct._globalBatch;for(let d=0;d<this.drawCalls.length;d++)this.drawCalls[d].texArray.clear(),nt.push(this.drawCalls[d]);this.drawCalls.length=0;const e=this.colors,s=this.textureIds;let i=nt.pop();i||(i=new Rt,i.texArray=new Et),i.texArray.count=0,i.start=0,i.size=0,i.type=ht.TRIANGLES;let h=0,n=null,r=0,a=!1,o=ht.TRIANGLES,l=0;this.drawCalls.push(i);for(let d=0;d<this.batches.length;d++){const u=this.batches[d],b=8,p=u.style,y=p.texture.baseTexture;a!==!!p.native&&(a=!!p.native,o=a?ht.LINES:ht.TRIANGLES,n=null,h=b,t++),n!==y&&(n=y,y._batchEnabled!==t&&(h===b&&(t++,h=0,i.size>0&&(i=nt.pop(),i||(i=new Rt,i.texArray=new Et),this.drawCalls.push(i)),i.start=l,i.size=0,i.texArray.count=0,i.type=o),y.touched=1,y._batchEnabled=t,y._batchLocation=h,y.wrapMode=Dt.REPEAT,i.texArray.elements[i.texArray.count++]=y,h++)),i.size+=u.size,l+=u.size,r=y._batchLocation,this.addColors(e,p.color,p.alpha,u.attribSize,u.attribStart),this.addTextureIds(s,r,u.attribSize,u.attribStart)}Ct._globalBatch=t,this.packAttributes()}packAttributes(){const t=this.points,e=this.uvs,s=this.colors,i=this.textureIds,h=new ArrayBuffer(t.length*3*4),n=new Float32Array(h),r=new Uint32Array(h);let a=0;for(let o=0;o<t.length/2;o++)n[a++]=t[o*2],n[a++]=t[o*2+1],n[a++]=e[o*2],n[a++]=e[o*2+1],r[a++]=s[o],n[a++]=i[o];this._buffer.update(h),this._indexBuffer.update(this.indicesUint16)}processFill(t){t.holes.length?kt.triangulate(t,this):pt[t.type].triangulate(t,this)}processLine(t){Ut(t,this);for(let e=0;e<t.holes.length;e++)Ut(t.holes[e],this)}processHoles(t){for(let e=0;e<t.length;e++){const s=t[e];pt[s.type].build(s),s.matrix&&this.transformPoints(s.points,s.matrix)}}calculateBounds(){const t=this._bounds;t.clear(),t.addVertexData(this.points,0,this.points.length),t.pad(this.boundsPadding,this.boundsPadding)}transformPoints(t,e){for(let s=0;s<t.length/2;s++){const i=t[s*2],h=t[s*2+1];t[s*2]=e.a*i+e.c*h+e.tx,t[s*2+1]=e.b*i+e.d*h+e.ty}}addColors(t,e,s,i,h=0){const n=U.shared.setValue(e).toLittleEndianNumber(),r=U.shared.setValue(n).toPremultiplied(s);t.length=Math.max(t.length,h+i);for(let a=0;a<i;a++)t[h+a]=r}addTextureIds(t,e,s,i=0){t.length=Math.max(t.length,i+s);for(let h=0;h<s;h++)t[i+h]=e}addUvs(t,e,s,i,h,n=null){let r=0;const a=e.length,o=s.frame;for(;r<h;){let d=t[(i+r)*2],u=t[(i+r)*2+1];if(n){const b=n.a*d+n.c*u+n.tx;u=n.b*d+n.d*u+n.ty,d=b}r++,e.push(d/o.width,u/o.height)}const l=s.baseTexture;(o.width<l.width||o.height<l.height)&&this.adjustUvs(e,s,a,h)}adjustUvs(t,e,s,i){const h=e.baseTexture,n=1e-6,r=s+i*2,a=e.frame,o=a.width/h.width,l=a.height/h.height;let d=a.x/a.width,u=a.y/a.height,b=Math.floor(t[s]+n),p=Math.floor(t[s+1]+n);for(let y=s+2;y<r;y+=2)b=Math.min(b,Math.floor(t[y]+n)),p=Math.min(p,Math.floor(t[y+1]+n));d-=b,u-=p;for(let y=s;y<r;y+=2)t[y]=(t[y]+d)*o,t[y+1]=(t[y+1]+u)*l}};qt.BATCHABLE_SIZE=100;let De=qt;class ut{constructor(){this.color=16777215,this.alpha=1,this.texture=J.WHITE,this.matrix=null,this.visible=!1,this.reset()}clone(){const t=new ut;return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.visible=this.visible,t}reset(){this.color=16777215,this.alpha=1,this.texture=J.WHITE,this.matrix=null,this.visible=!1}destroy(){this.texture=null,this.matrix=null}}class xt extends ut{constructor(){super(...arguments),this.width=0,this.alignment=.5,this.native=!1,this.cap=L.BUTT,this.join=A.MITER,this.miterLimit=10}clone(){const t=new xt;return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.visible=this.visible,t.width=this.width,t.alignment=this.alignment,t.native=this.native,t.cap=this.cap,t.join=this.join,t.miterLimit=this.miterLimit,t}reset(){super.reset(),this.color=0,this.alignment=.5,this.width=0,this.native=!1,this.cap=L.BUTT,this.join=A.MITER,this.miterLimit=10}}const gt={},bt=class rt extends Ot{constructor(t=null){super(),this.shader=null,this.pluginName="batch",this.currentPath=null,this.batches=[],this.batchTint=-1,this.batchDirty=-1,this.vertexData=null,this._fillStyle=new ut,this._lineStyle=new xt,this._matrix=null,this._holeMode=!1,this.state=Ft.for2d(),this._geometry=t||new De,this._geometry.refCount++,this._transformID=-1,this._tintColor=new U(16777215),this.blendMode=jt.NORMAL}get geometry(){return this._geometry}clone(){return this.finishPoly(),new rt(this._geometry)}set blendMode(t){this.state.blendMode=t}get blendMode(){return this.state.blendMode}get tint(){return this._tintColor.value}set tint(t){this._tintColor.setValue(t)}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(t=null,e=0,s,i=.5,h=!1){return typeof t=="number"&&(t={width:t,color:e,alpha:s,alignment:i,native:h}),this.lineTextureStyle(t)}lineTextureStyle(t){const e={width:0,texture:J.WHITE,color:t!=null&&t.texture?16777215:0,matrix:null,alignment:.5,native:!1,cap:L.BUTT,join:A.MITER,miterLimit:10};t=Object.assign(e,t),this.normalizeColor(t),this.currentPath&&this.startPoly();const s=t.width>0&&t.alpha>0;return s?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._lineStyle,{visible:s},t)):this._lineStyle.reset(),this}startPoly(){if(this.currentPath){const t=this.currentPath.points,e=this.currentPath.points.length;e>2&&(this.drawShape(this.currentPath),this.currentPath=new ct,this.currentPath.closeStroke=!1,this.currentPath.points.push(t[e-2],t[e-1]))}else this.currentPath=new ct,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(this.currentPath.points.length>2?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(t,e){return this.startPoly(),this.currentPath.points[0]=t,this.currentPath.points[1]=e,this}lineTo(t,e){this.currentPath||this.moveTo(0,0);const s=this.currentPath.points,i=s[s.length-2],h=s[s.length-1];return(i!==t||h!==e)&&s.push(t,e),this}_initCurve(t=0,e=0){this.currentPath?this.currentPath.points.length===0&&(this.currentPath.points=[t,e]):this.moveTo(t,e)}quadraticCurveTo(t,e,s,i){this._initCurve();const h=this.currentPath.points;return h.length===0&&this.moveTo(0,0),ft.curveTo(t,e,s,i,h),this}bezierCurveTo(t,e,s,i,h,n){return this._initCurve(),mt.curveTo(t,e,s,i,h,n,this.currentPath.points),this}arcTo(t,e,s,i,h){this._initCurve(t,e);const n=this.currentPath.points,r=At.curveTo(t,e,s,i,h,n);if(r){const{cx:a,cy:o,radius:l,startAngle:d,endAngle:u,anticlockwise:b}=r;this.arc(a,o,l,d,u,b)}return this}arc(t,e,s,i,h,n=!1){if(i===h)return this;if(!n&&h<=i?h+=yt:n&&i<=h&&(i+=yt),h-i===0)return this;const r=t+Math.cos(i)*s,a=e+Math.sin(i)*s,o=this._geometry.closePointEps;let l=this.currentPath?this.currentPath.points:null;if(l){const d=Math.abs(l[l.length-2]-r),u=Math.abs(l[l.length-1]-a);d<o&&u<o||l.push(r,a)}else this.moveTo(r,a),l=this.currentPath.points;return At.arc(r,a,t,e,s,i,h,n,l),this}beginFill(t=0,e){return this.beginTextureFill({texture:J.WHITE,color:t,alpha:e})}normalizeColor(t){const e=U.shared.setValue(t.color??0);t.color=e.toNumber(),t.alpha??(t.alpha=e.alpha)}beginTextureFill(t){const e={texture:J.WHITE,color:16777215,matrix:null};t=Object.assign(e,t),this.normalizeColor(t),this.currentPath&&this.startPoly();const s=t.alpha>0;return s?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._fillStyle,{visible:s},t)):this._fillStyle.reset(),this}endFill(){return this.finishPoly(),this._fillStyle.reset(),this}drawRect(t,e,s,i){return this.drawShape(new Jt(t,e,s,i))}drawRoundedRect(t,e,s,i,h){return this.drawShape(new te(t,e,s,i,h))}drawCircle(t,e,s){return this.drawShape(new ee(t,e,s))}drawEllipse(t,e,s,i){return this.drawShape(new ie(t,e,s,i))}drawPolygon(...t){let e,s=!0;const i=t[0];i.points?(s=i.closeStroke,e=i.points):Array.isArray(t[0])?e=t[0]:e=t;const h=new ct(e);return h.closeStroke=s,this.drawShape(h),this}drawShape(t){return this._holeMode?this._geometry.drawHole(t,this._matrix):this._geometry.drawShape(t,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this}clear(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this}isFastRect(){const t=this._geometry.graphicsData;return t.length===1&&t[0].shape.type===B.RECT&&!t[0].matrix&&!t[0].holes.length&&!(t[0].lineStyle.visible&&t[0].lineStyle.width)}_render(t){this.finishPoly();const e=this._geometry;e.updateBatches(),e.batchable?(this.batchDirty!==e.batchDirty&&this._populateBatches(),this._renderBatched(t)):(t.batch.flush(),this._renderDirect(t))}_populateBatches(){const t=this._geometry,e=this.blendMode,s=t.batches.length;this.batchTint=-1,this._transformID=-1,this.batchDirty=t.batchDirty,this.batches.length=s,this.vertexData=new Float32Array(t.points);for(let i=0;i<s;i++){const h=t.batches[i],n=h.style.color,r=new Float32Array(this.vertexData.buffer,h.attribStart*4*2,h.attribSize*2),a=new Float32Array(t.uvsFloat32.buffer,h.attribStart*4*2,h.attribSize*2),o=new Uint16Array(t.indicesUint16.buffer,h.start*2,h.size),l={vertexData:r,blendMode:e,indices:o,uvs:a,_batchRGB:U.shared.setValue(n).toRgbArray(),_tintRGB:n,_texture:h.style.texture,alpha:h.style.alpha,worldAlpha:1};this.batches[i]=l}}_renderBatched(t){if(this.batches.length){t.batch.setObjectRenderer(t.plugins[this.pluginName]),this.calculateVertices(),this.calculateTints();for(let e=0,s=this.batches.length;e<s;e++){const i=this.batches[e];i.worldAlpha=this.worldAlpha*i.alpha,t.plugins[this.pluginName].render(i)}}}_renderDirect(t){const e=this._resolveDirectShader(t),s=this._geometry,i=this.worldAlpha,h=e.uniforms,n=s.drawCalls;h.translationMatrix=this.transform.worldTransform,U.shared.setValue(this._tintColor).premultiply(i).toArray(h.tint),t.shader.bind(e),t.geometry.bind(s,e),t.state.set(this.state);for(let r=0,a=n.length;r<a;r++)this._renderDrawCallDirect(t,s.drawCalls[r])}_renderDrawCallDirect(t,e){const{texArray:s,type:i,size:h,start:n}=e,r=s.count;for(let a=0;a<r;a++)t.texture.bind(s.elements[a],a);t.geometry.draw(i,h,n)}_resolveDirectShader(t){let e=this.shader;const s=this.pluginName;if(!e){if(!gt[s]){const{maxTextures:i}=t.plugins[s],h=new Int32Array(i);for(let a=0;a<i;a++)h[a]=a;const n={tint:new Float32Array([1,1,1,1]),translationMatrix:new Lt,default:ce.from({uSamplers:h},!0)},r=t.plugins[s]._shader.program;gt[s]=new Vt(r,n)}e=gt[s]}return e}_calculateBounds(){this.finishPoly();const t=this._geometry;if(!t.graphicsData.length)return;const{minX:e,minY:s,maxX:i,maxY:h}=t.bounds;this._bounds.addFrame(this.transform,e,s,i,h)}containsPoint(t){return this.worldTransform.applyInverse(t,rt._TEMP_POINT),this._geometry.containsPoint(rt._TEMP_POINT)}calculateTints(){if(this.batchTint!==this.tint){this.batchTint=this._tintColor.toNumber();for(let t=0;t<this.batches.length;t++){const e=this.batches[t];e._tintRGB=U.shared.setValue(this._tintColor).multiply(e._batchRGB).toLittleEndianNumber()}}}calculateVertices(){const t=this.transform._worldID;if(this._transformID===t)return;this._transformID=t;const e=this.transform.worldTransform,s=e.a,i=e.b,h=e.c,n=e.d,r=e.tx,a=e.ty,o=this._geometry.points,l=this.vertexData;let d=0;for(let u=0;u<o.length;u+=2){const b=o[u],p=o[u+1];l[d++]=s*b+h*p+r,l[d++]=n*p+i*b+a}}closePath(){const t=this.currentPath;return t&&(t.closeStroke=!0,this.finishPoly()),this}setMatrix(t){return this._matrix=t,this}beginHole(){return this.finishPoly(),this._holeMode=!0,this}endHole(){return this.finishPoly(),this._holeMode=!1,this}destroy(t){this._geometry.refCount--,this._geometry.refCount===0&&this._geometry.dispose(),this._matrix=null,this.currentPath=null,this._lineStyle.destroy(),this._lineStyle=null,this._fillStyle.destroy(),this._fillStyle=null,this._geometry=null,this.shader=null,this.vertexData=null,this.batches.length=0,this.batches=null,super.destroy(t)}};bt.curves=Y,bt._TEMP_POINT=new at;let Ce=bt;function N(c,t){return Math.random()*(t-c)+c}const I=class I extends de{constructor(e){super(I.texture);q(this,"vx");q(this,"vy");this.x=e.x,this.y=e.y,this.vx=e.vx,this.vy=e.vy,this.alpha=e.alpha}static getRandomParticle(){return new I({x:N(0,I.app.renderer.width),y:-5,vx:N(-2,2),vy:N(8,10),alpha:N(0,1)})}static getRandomParticles(e){return Array.from({length:e},(s,i)=>I.getRandomParticle())}reset(){this.x=N(0,I.app.renderer.width),this.y=0,this.vx=N(-3,3)}randomize(){this.vx+=N(-1,1),this.vy=N(2,6)}update(e){this.y>0&&(this.x+=this.vx),this.y+=this.vy,Math.random()>.9&&this.randomize(),(this.x>I.app.renderer.width||this.x<0||this.y>I.app.renderer.height)&&this.reset()}};q(I,"graphics",new Ce().beginFill(new se(16777215)).drawCircle(K.snow.size/2,K.snow.size/2,K.snow.size).endFill()),q(I,"texture"),q(I,"app");let W=I;class Re extends Ot{constructor(t=1500,e,s=16384,i=!1){super();const h=16384;s>h&&(s=h),this._properties=[!1,!0,!1,!1,!1],this._maxSize=t,this._batchSize=s,this._buffers=null,this._bufferUpdateIDs=[],this._updateID=0,this.interactiveChildren=!1,this.blendMode=jt.NORMAL,this.autoResize=i,this.roundPixels=!0,this.baseTexture=null,this.setProperties(e),this._tintColor=new U(0),this.tintRgb=new Float32Array(3),this.tint=16777215}setProperties(t){t&&(this._properties[0]="vertices"in t||"scale"in t?!!t.vertices||!!t.scale:this._properties[0],this._properties[1]="position"in t?!!t.position:this._properties[1],this._properties[2]="rotation"in t?!!t.rotation:this._properties[2],this._properties[3]="uvs"in t?!!t.uvs:this._properties[3],this._properties[4]="tint"in t||"alpha"in t?!!t.tint||!!t.alpha:this._properties[4])}updateTransform(){this.displayObjectUpdateTransform()}get tint(){return this._tintColor.value}set tint(t){this._tintColor.setValue(t),this._tintColor.toRgbArray(this.tintRgb)}render(t){!this.visible||this.worldAlpha<=0||!this.children.length||!this.renderable||(this.baseTexture||(this.baseTexture=this.children[0]._texture.baseTexture,this.baseTexture.valid||this.baseTexture.once("update",()=>this.onChildrenChange(0))),t.batch.setObjectRenderer(t.plugins.particle),t.plugins.particle.render(this))}onChildrenChange(t){const e=Math.floor(t/this._batchSize);for(;this._bufferUpdateIDs.length<e;)this._bufferUpdateIDs.push(0);this._bufferUpdateIDs[e]=++this._updateID}dispose(){if(this._buffers){for(let t=0;t<this._buffers.length;++t)this._buffers[t].destroy();this._buffers=null}}destroy(t){super.destroy(t),this.dispose(),this._properties=null,this._buffers=null,this._bufferUpdateIDs=null}}class Nt{constructor(t,e,s){this.geometry=new pe,this.indexBuffer=null,this.size=s,this.dynamicProperties=[],this.staticProperties=[];for(let i=0;i<t.length;++i){let h=t[i];h={attributeName:h.attributeName,size:h.size,uploadFunction:h.uploadFunction,type:h.type||H.FLOAT,offset:h.offset},e[i]?this.dynamicProperties.push(h):this.staticProperties.push(h)}this.staticStride=0,this.staticBuffer=null,this.staticData=null,this.staticDataUint32=null,this.dynamicStride=0,this.dynamicBuffer=null,this.dynamicData=null,this.dynamicDataUint32=null,this._updateID=0,this.initBuffers()}initBuffers(){const t=this.geometry;let e=0;this.indexBuffer=new dt(we(this.size),!0,!0),t.addIndex(this.indexBuffer),this.dynamicStride=0;for(let n=0;n<this.dynamicProperties.length;++n){const r=this.dynamicProperties[n];r.offset=e,e+=r.size,this.dynamicStride+=r.size}const s=new ArrayBuffer(this.size*this.dynamicStride*4*4);this.dynamicData=new Float32Array(s),this.dynamicDataUint32=new Uint32Array(s),this.dynamicBuffer=new dt(this.dynamicData,!1,!1);let i=0;this.staticStride=0;for(let n=0;n<this.staticProperties.length;++n){const r=this.staticProperties[n];r.offset=i,i+=r.size,this.staticStride+=r.size}const h=new ArrayBuffer(this.size*this.staticStride*4*4);this.staticData=new Float32Array(h),this.staticDataUint32=new Uint32Array(h),this.staticBuffer=new dt(this.staticData,!0,!1);for(let n=0;n<this.dynamicProperties.length;++n){const r=this.dynamicProperties[n];t.addAttribute(r.attributeName,this.dynamicBuffer,0,r.type===H.UNSIGNED_BYTE,r.type,this.dynamicStride*4,r.offset*4)}for(let n=0;n<this.staticProperties.length;++n){const r=this.staticProperties[n];t.addAttribute(r.attributeName,this.staticBuffer,0,r.type===H.UNSIGNED_BYTE,r.type,this.staticStride*4,r.offset*4)}}uploadDynamic(t,e,s){for(let i=0;i<this.dynamicProperties.length;i++){const h=this.dynamicProperties[i];h.uploadFunction(t,e,s,h.type===H.UNSIGNED_BYTE?this.dynamicDataUint32:this.dynamicData,this.dynamicStride,h.offset)}this.dynamicBuffer._updateID++}uploadStatic(t,e,s){for(let i=0;i<this.staticProperties.length;i++){const h=this.staticProperties[i];h.uploadFunction(t,e,s,h.type===H.UNSIGNED_BYTE?this.staticDataUint32:this.staticData,this.staticStride,h.offset)}this.staticBuffer._updateID++}destroy(){this.indexBuffer=null,this.dynamicProperties=null,this.dynamicBuffer=null,this.dynamicData=null,this.dynamicDataUint32=null,this.staticProperties=null,this.staticBuffer=null,this.staticData=null,this.staticDataUint32=null,this.geometry.destroy()}}var Ee=`varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`,Ie=`attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;class Ht extends be{constructor(t){super(t),this.shader=null,this.properties=null,this.tempMatrix=new Lt,this.properties=[{attributeName:"aVertexPosition",size:2,uploadFunction:this.uploadVertices,offset:0},{attributeName:"aPositionCoord",size:2,uploadFunction:this.uploadPosition,offset:0},{attributeName:"aRotation",size:1,uploadFunction:this.uploadRotation,offset:0},{attributeName:"aTextureCoord",size:2,uploadFunction:this.uploadUvs,offset:0},{attributeName:"aColor",size:1,type:H.UNSIGNED_BYTE,uploadFunction:this.uploadTint,offset:0}],this.shader=Vt.from(Ie,Ee,{}),this.state=Ft.for2d()}render(t){const e=t.children,s=t._maxSize,i=t._batchSize,h=this.renderer;let n=e.length;if(n===0)return;n>s&&!t.autoResize&&(n=s);let r=t._buffers;r||(r=t._buffers=this.generateBuffers(t));const a=e[0]._texture.baseTexture,o=a.alphaMode>0;this.state.blendMode=me(t.blendMode,o),h.state.set(this.state);const l=h.gl,d=t.worldTransform.copyTo(this.tempMatrix);d.prepend(h.globalUniforms.uniforms.projectionMatrix),this.shader.uniforms.translationMatrix=d.toArray(!0),this.shader.uniforms.uColor=U.shared.setValue(t.tintRgb).premultiply(t.worldAlpha,o).toArray(this.shader.uniforms.uColor),this.shader.uniforms.uSampler=a,this.renderer.shader.bind(this.shader);let u=!1;for(let b=0,p=0;b<n;b+=i,p+=1){let y=n-b;y>i&&(y=i),p>=r.length&&r.push(this._generateOneMoreBuffer(t));const x=r[p];x.uploadDynamic(e,b,y);const f=t._bufferUpdateIDs[p]||0;u=u||x._updateID<f,u&&(x._updateID=t._updateID,x.uploadStatic(e,b,y)),h.geometry.bind(x.geometry),l.drawElements(l.TRIANGLES,y*6,l.UNSIGNED_SHORT,0)}}generateBuffers(t){const e=[],s=t._maxSize,i=t._batchSize,h=t._properties;for(let n=0;n<s;n+=i)e.push(new Nt(this.properties,h,i));return e}_generateOneMoreBuffer(t){const e=t._batchSize,s=t._properties;return new Nt(this.properties,s,e)}uploadVertices(t,e,s,i,h,n){let r=0,a=0,o=0,l=0;for(let d=0;d<s;++d){const u=t[e+d],b=u._texture,p=u.scale.x,y=u.scale.y,x=b.trim,f=b.orig;x?(a=x.x-u.anchor.x*f.width,r=a+x.width,l=x.y-u.anchor.y*f.height,o=l+x.height):(r=f.width*(1-u.anchor.x),a=f.width*-u.anchor.x,o=f.height*(1-u.anchor.y),l=f.height*-u.anchor.y),i[n]=a*p,i[n+1]=l*y,i[n+h]=r*p,i[n+h+1]=l*y,i[n+h*2]=r*p,i[n+h*2+1]=o*y,i[n+h*3]=a*p,i[n+h*3+1]=o*y,n+=h*4}}uploadPosition(t,e,s,i,h,n){for(let r=0;r<s;r++){const a=t[e+r].position;i[n]=a.x,i[n+1]=a.y,i[n+h]=a.x,i[n+h+1]=a.y,i[n+h*2]=a.x,i[n+h*2+1]=a.y,i[n+h*3]=a.x,i[n+h*3+1]=a.y,n+=h*4}}uploadRotation(t,e,s,i,h,n){for(let r=0;r<s;r++){const a=t[e+r].rotation;i[n]=a,i[n+h]=a,i[n+h*2]=a,i[n+h*3]=a,n+=h*4}}uploadUvs(t,e,s,i,h,n){for(let r=0;r<s;++r){const a=t[e+r]._texture._uvs;a?(i[n]=a.x0,i[n+1]=a.y0,i[n+h]=a.x1,i[n+h+1]=a.y1,i[n+h*2]=a.x2,i[n+h*2+1]=a.y2,i[n+h*3]=a.x3,i[n+h*3+1]=a.y3,n+=h*4):(i[n]=0,i[n+1]=0,i[n+h]=0,i[n+h+1]=0,i[n+h*2]=0,i[n+h*2+1]=0,i[n+h*3]=0,i[n+h*3+1]=0,n+=h*4)}}uploadTint(t,e,s,i,h,n){for(let r=0;r<s;++r){const a=t[e+r],o=U.shared.setValue(a._tintRGB).toPremultiplied(a.alpha,a.texture.baseTexture.alphaMode>0);i[n]=o,i[n+h]=o,i[n+h*2]=o,i[n+h*3]=o,n+=h*4}}destroy(){super.destroy(),this.shader&&(this.shader.destroy(),this.shader=null),this.tempMatrix=null}}Ht.extension={name:"particle",type:ge.RendererPlugin};ye.add(Ht);function ze(){const c=he(null),t=ne(re);if(t.load(),!t.settings.value.enableSnow)return null;function e(){const s=new fe({width:window.innerWidth,height:window.innerHeight,resizeTo:window,view:c.current,backgroundAlpha:0,antialias:!0});W.texture=s.renderer.generateTexture(W.graphics),W.app=s;const i=W.getRandomParticles(K.snow.amount),h=new Re(K.snow.amount,{scale:!0,position:!0});i.forEach(n=>h.addChild(n)),s.stage.addChild(h),s.ticker.add(n=>i.forEach(r=>r.update(n)))}return Mt(e,[]),Mt(e,[t.settings.value]),ae("canvas",{ref:c,className:_e.snow})}export{ze as Snow};
